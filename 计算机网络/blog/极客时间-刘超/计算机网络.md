# 计算机网络

- [9.路由协议](#9.路由协议)
- [10.UDP](#10.UDP)
- [11.TCP上](#11.TCP上)
- [12.TCP下](#12.TCP下)
- [13.Socket编程](#13.Socket编程)


## 9.路由协议

---
### 配置路由
---
#### 静态路由

- 路由表
  - 目标地址
  - 出口设备
  - 下一跳网关
  - 核心：根据目的 IP 地址来配置路由
- 策略路由
  - 可以配置多个路由表，可以根据源 IP 地址、入口设备、TOS 等选择路由表，然后在路由表中查找路由。这样可以使得来自不同来源的包走不同的路由。

---
#### 动态路由

使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。

- 距离矢量路由算法
  - 算法：Bellman-Ford
  - 具体
    - 每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居，每个路由器也能从邻居那里得到相似的信息。每个路由器根据新收集的信息，计算和其他路由器的距离，比如自己的一个邻居距离目标路由器的距离是 M，而自己距离邻居是 x，则自己距离目标路由器是 x+M。
  - 问题
    - 好消息传得快，坏消息传得慢
    - 每次发送的时候，要发送整个全局路由表
- 链路状态路由算法
  - 算法：Dijkstra
  - 具体
    - 每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径

---
### 动态路由协议

-  基于链路状态路由算法的 OSPF
   -  OSPF（Open Shortest Path First，开放式最短路径优先）
   -  内部网关协议（Interior Gateway Protocol，简称 IGP）
   -  等价路由（负载均衡）
-  基于距离矢量路由算法的 BGP
   -  外网路由协议（Border Gateway Protocol，简称 BGP）
   -  数据中心的Policy，有些包不能转发
   -  AS（Autonomous System）
      -  分类
        -  Stub AS：对外只有一个连接。这类 AS 不会传输其他 AS 的包。例如，个人或者小公司的网络。
        -  Multihomed AS：可能有多个连接连到其他的 AS，但是大多拒绝帮其他的 AS 传输包。例如一些大公司的网络。
        -  Transit AS：有多个连接连到其他的 AS，并且可以帮助其他的 AS 传输包。例如主干网。
      - 每个自治系统都有边界路由器，通过它和外面的世界建立联系。
   - 分类
     - eBGP
       - 边界路由器之间使用 eBGP 广播路由
     - iBGP
       - 边界路由器如何将 BGP 学习到的路由导入到内部网络呢？就是通过运行 iBGP，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。
     - 子网比较大，表中内容比较少，规避了距离矢量算法的两个问题

---
### 小结

- 路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；
- 动态路由主流算法有两种，距离矢量算法和链路状态算法。基于两种算法产生两种协议，BGP 协议和 OSPF 协议。

---
## 10.UDP
---
### TCP与UDP的区别

- TCP
  - 面向连接的
    - 建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性
  - TCP 提供可靠交付
  - TCP 是面向字节流的
  - TCP 是可以有拥塞控制的
  - 因而 TCP 其实是一个有状态服务
- UDP
  - 无连接的
  - UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达
  - 基于数据报的，一个一个地发，一个一个地收
  - UDP 就不会，应用让我发，我就发
  - UDP 则是无状态服务

我们可以这样比喻，如果 MAC 层定义了本地局域网的传输行为，IP 层定义了整个网络端到端的传输行为，这两层基本定义了这样的基因：**网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。我们笼统地称为包。包单独传输，自行选路，在不同的设备封装解封装，不保证到达**。基于这个基因，生下来的孩子 UDP 完全继承了这些特性，几乎没有自己的思想。

---
### UDP
---
#### 包头

- IP头中有一个8位协议
  - TCP
  - UDP
- UDP头
  - 源端口号-16
  - 目标端口号-16
  - UDP长度-16
  - UDP校验和-16
  - 数据

---
#### 三大特点

- 沟通简单
  - 设定少
  - 处理逻辑简单
- 轻信他人
  - 不建立连接
- 不权变
  - 不拥塞控制

---
#### 三大使用场景

- 资源少，网络好，或者丢包不敏感
  - DHCP（内网）
  - PXE种的TFTP（客户端无OS，资源少，维护不了TCP）
  - 流媒体（丢包不敏感）
- 不需要连接，可以广播使用
  - DHCP
  - 组播地址-IGMP
  - 云服务-VXLAN
- 时延低，网络拥塞时也不减速
  - 流媒体
  - 实时游戏

---
### UDP的5个例子

- QUIC
  - 网页，APP的访问
- 流媒体协议
  - 丢包无意义
- 实时游戏
  - 接受不了延迟
- IoT物联网
  - TCP太耗资源
- 移动通信
  - 4G的GTP-U

---
### 小结

- 如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；TCP 维护连接，UDP 谁都相信；TCP 会坚持知进退；UDP 愣头青一个，勇往直前；
- UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。

---
## 11.TCP上

---
### 包头

- 源端口号-16
- 目标端口号-16
- 序号-32
- 确认序号-32
- 首部长度-4
- 保留-6
- 状态位-6
- 窗口大小-16
- 校验和-16
- 紧急指针-16
- 选项
- 数据

---
### 要解决的问题

- 顺序问题
- 丢包问题
- 连接维护
- 流量控制
- 拥塞控制

---
### 三次握手

![三次握手](.\pic\计算机网络\TCP\三次握手.jpg)

- 连接维护的问题
  - 三次握手
    - 目的1-建立连接
      - 请求
      - 应答
      - 应答之应答
    - 目的2-TCP 包的序号的问题
  - keepalive-探活包


---
### 四次挥手

![四次挥手](.\pic\计算机网络\TCP\四次挥手.jpg)

等待的时间设为 2MSL，MSL 是 Maximum Segment Lifetime，报文最大生存时间

---
### TCP状态机

![TCP状态机](.\pic\计算机网络\TCP\TCP状态机.jpg)

---
### 小结

- TCP 包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制；
- 连接的建立是经过三次握手，断开的时候四次挥手，一定要掌握的我画的那个状态图。

---
## 12.TCP下

### 编号

给每个包编个号

### 接收端、发送端数据结构

累计应答（cumulative acknowledgment）


![数据结构1](.\pic\计算机网络\TCP\数据结构1.jpg)

- 四个部分
  - 发送了并且已经确认的
  - 发送了并且尚未确认的
  - 没有发送，但是已经等待发送的
  - 没有发送，并且暂时还不会发送的
- 发送端数据结构
  - LastByteAcked：第一部分和第二部分的分界线
  - LastByteSent：第二部分和第三部分的分界线
  - LastByteAcked + AdvertisedWindow：第三部分和第四部分的分界线

![数据结构2](.\pic\计算机网络\TCP\数据结构2.jpg)

- 三个部分
  - 接受并且确认过的
  - 还没接收，但是马上就能接收的
  - 还没接收，也没法接收的
- 接收端数据结构
  - MaxRcvBuffer：最大缓存的量；
  - LastByteRead 之后是已经接收了，但是还没被应用层读取的；
  - NextByteExpected 是第一部分和第二部分的分界线。

### 顺序问题与丢包问题

- 确认与重发的机制
  - 超时重试
    - 往返时间 RTT
    - 用RTT估计超时时间
      - 自适应重传算法（Adaptive Retransmission Algorithm）
    - 超时间隔加倍
      - 每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送
  - 快速重传的机制
      - 发送三个冗余的 ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段
  - Selective Acknowledgment  （SACK）
    - 这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。例如可以发送 ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是 7 丢了。

### 流量控制

- 根据数据处理情况，修改窗口的大小。
- 在为0时，发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小

### 拥塞问题

通过窗口的大小来控制的，前面的滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满。

LastByteSent - LastByteAcked <= min {cwnd, rwnd}

- 目的
  - 避免包丢失
  - 避免超时重传

#### 慢启动

一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd 加一，于是一次能够发送两个；当这两个的确认到来的时候，每个确认 cwnd 加一，两个确认 cwnd 加二，于是一次能够发送四个；当这四个的确认到来的时候，每个确认 cwnd 加一，四个确认 cwnd 加四，于是一次能够发送八个。可以看出这是指数性的增长。

涨到什么时候是个头呢？有一个值 ssthresh 为 65535 个字节，当超过这个值的时候，就要小心一点了，不能倒这么快了，可能快满了，再慢下来。

每收到一个确认后，cwnd 增加 1/cwnd，我们接着上面的过程来，一次发送八个，当八个确认到来的时候，每个确认增加 1/8，八个确认一共 cwnd 增加 1，于是一次能够发送九个，变成了线性增长。

但是线性增长还是增长，还是越来越多，直到有一天，水满则溢，出现了拥塞，这时候一般就会一下子降低倒水的速度，等待溢出的水慢慢渗下去。

拥塞的一种表现形式是丢包，需要超时重传，这个时候，将 sshresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动。这真是一旦超时重传，马上回到解放前。但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。

- 两个问题
  - 第一个问题是丢包并不代表着通道满了，也可能是管子本来就漏水（公网丢包）
  - 第二个问题是 TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了
- 解决方法
  -  TCP BBR 拥塞算法

![BBR](.\pic\计算机网络\TCP\BBR.jpg)

### 小结

- 顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的，这其实就相当于你领导和你的工作备忘录，布置过的工作要有编号，干完了有反馈，活不能派太多，也不能太少；
- 拥塞控制是通过拥塞窗口来解决的，相当于往管道里面倒水，快了容易溢出，慢了浪费带宽，要摸着石头过河，找到最优值。



---
## 13.Socket编程

### 基于 TCP 协议的 Socket 程序函数调用过程

### 基于 UDP 协议的 Socket 程序函数调用过程

### 服务器提供多个服务




### 小结

- 你需要记住 TCP 和 UDP 的 Socket 的编程中，客户端和服务端都需要调用哪些函数；
- 写一个能够支撑大量连接的高并发的服务端不容易，需要多进程、多线程，而 epoll 机制能解决 C10K 问题。

---