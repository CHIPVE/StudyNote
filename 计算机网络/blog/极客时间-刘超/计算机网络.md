# 计算机网络

- [1.网络协议](#1.网络协议)
- [2.网络分层](#2.网络分层)
- [3.ifconfig:ip](#3.ifconfig:ip)
- [4.DHCP与PXE](#4.DHCP与PXE)
- [5.物理层与MAC层](#5.物理层与MAC层)
- [6.交换机与VLAN（STP，VLAN）](#6.交换机与VLAN)
- [7.ICMP与ping](#7.ICMP与ping)
- [8.静态路由、转发网管和NAT网关](#8.静态路由、转发网管和NAT网关)
- [9.动态路由](#9.动态路由)
- [10.UDP](#10.UDP)
- [11.TCP连接](#11.TCP连接)
- [12.TCP策略](#12.TCP策略)
- [13.socket编程](#13.socket编程)
- [14.HTTP](#14.HTTP)
- [15.HTTPS](#15.HTTPS)
- [16.流媒体协议](#16.流媒体协议)
- [17.P2P](#17.P2P)
- [18.DNS](#18.DNS)
- [19.HTTPDNS](#19.HTTPDNS)
- [20.CDN](#20.CDN)
- [21.数据中心](#21.数据中心)
- [22.VPN](#22.VPN)
- [23.移动网络](#23.移动网络)



## 1.网络协议

---
### 协议的三要素

- 语法
  - 状态
  - 首部
  - 内容
- 语义
  - 200
  - 404
- 顺序
  - 发送
  - 接收

---
### 常用的网络协议

- 应用层
  - 输入URL
    - DNS
    - HTTPDNS
  - 获得IP
  - 发送请求
    - HTTP
    - HTTPS
- 传输层
  - UDP
  - TCP
- 网络层
  - IP
  - 路由协议
    - OSPF
    - BGP
  - ICMP
  - IPSec
  - GRE
- MAC层
  - ARP
    - 获得MAC
  - VLAN
  - STP
- 服务器端
  - Tomcat
  - RPC

---
## 2.网络分层

---
### 网络问什么要分层

复杂的程序都要分层

---
### 处理网络包的程序如何工作

- process_layer2(buffer)
- process_layer3(buffer)
- process_tcp(buffer)
- 浏览器
- send_tcp(buffer)
- send_layer3(buffer)
- send_layer2(buffer)

---
### 层与层之间的关系

在网络中的包都是完整的，一定有底层的mac和ip

---
### 总结

- 始终想象自己是一个处理网络包的程序：如何拿到网络包，如何根据规则进行处理，如何发出去；
- 始终牢记一个原则：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。

---
## 3.ifconfig:ip

---
### 查看ip的指令

- Windows
  - ipconfig
- Linux
  - ifconfig
  - ip addr
    - IPV4
      - 10.100.122.2
    - IPV6
      - inet6 fe80::f816:3eff:fec7:7975/64
    - scope
      - global
      - host
    - lo
      - loopback
      - 127.0.0.1
    - mac
      - link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff
    - <BROADCAST,MULTICAST,UP,LOWER_UP>
      - net_device flags，网络设备的状态标识
    - 最大传输单元 MTU 为 1500，这是以太网的默认值
    - qdisc pfifo_fast
      - queueing discipline，中文叫排队规则
      - pfifo
      - pfifo_fast 
        - band 0
        - band 1
        - band 2
      - TOS（Type of Service）
        - IP头中，会分配到对应波段
- ABCDE5类ip

---
### 无类型域间选路（CIDR）

- 广播地址
- 子网掩码

---
### 举例：一个容易“犯错”的 CIDR

- IP：16.158.165.91/22
- 网络号：16.158.<101001>
- 机器号：<01>.91
- 第一个地址：16.158.<101001><00>.1；16.158.164.1
- 广播地址：16.158.<101001><11>.255；16.158.167.255

---
### 总结

- IP 是地址，有定位功能；MAC 是身份证，无定位功能；
- CIDR 可以用来判断是不是本地人；
- IP 分公有的 IP 和私有的 IP。后面的章节中我会谈到“出国门”，就与这个有关。

---
## 4.DHCP与PXE

---
### 如何配置IP

- net-tools
  - ifconfig
- iproute2
  - ip addr

Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。

不同系统的配置文件格式不同，但是无非就是 CIDR、子网掩码、广播地址和网关地址。

---
### 动态主机配置协议（DHCP）

如果是数据中心里面的服务器，IP 一旦配置好，基本不会变，这就相当于买房自己装修。DHCP 的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。

--- 
### 解析 DHCP 的工作方式

- DHCP Discover
  - 新来的机器使用 IP 地址 0.0.0.0 发送了一个广播包，目的 IP 地址为 255.255.255.255。广播包封装了 UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版，但是如果你去抓包的话，很可能看到的名称还是 BOOTP 协议。
- DHCP Offer
  - DHCP Server 仍然使用广播地址作为目的地址，因为，此时请求分配 IP 的新人还没有自己的 IP。DHCP Server 回复说，我分配了一个可用的 IP 给你，你看如何？除此之外，服务器还发送了子网掩码、网关和 IP 地址租用期等信息。
- 客户端
  - 客户端仍然使用 0.0.0.0 为源 IP 地址、255.255.255.255 为目标地址进行广播。
- DHCP Server
  - 当 DHCP Server 接收到客户机的 DHCP request 之后，会广播返回给客户机一个 DHCP ACK 消息包，表明已经接受客户机的选择，并将这一 IP 地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机，欢迎它加入网络大家庭。

---
### IP 地址的收回和续租

客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP request 消息包。客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及其他已经更新的 TCP/IP 参数，更新自己的配置。这样，IP 租用更新就完成了。

---
### 预启动执行环境（PXE）

Pre-boot Execution Environment

- PXE 协议分为客户端和服务器端
- 客户端
  - BIOS里面
- 服务器端

---
### 解析 PXE 的工作过程

首先，启动 PXE 客户端。第一步是通过 DHCP 协议告诉 DHCP Server，我刚来，一穷二白，啥都没有。DHCP Server 便租给它一个 IP 地址，同时也给它 PXE 服务器的地址、启动文件 pxelinux.0。

其次，PXE 客户端知道要去 PXE 服务器下载这个文件后，就可以初始化机器。于是便开始下载，下载的时候使用的是 TFTP 协议。所以 PXE 服务器上，往往还需要有一个 TFTP 服务器。PXE 客户端向 TFTP 服务器请求下载这个文件，TFTP 服务器说好啊，于是就将这个文件传给它。

然后，PXE 客户端收到这个文件后，就开始执行这个文件。这个文件会指示 PXE 客户端，向 TFTP 服务器请求计算机的配置信息 pxelinux.cfg。TFTP 服务器会给 PXE 客户端一个配置文件，里面会说内核在哪里、initramfs 在哪里。PXE 客户端会请求这些文件。

最后，启动 Linux 内核。一旦启动了操作系统，以后就啥都好办了。

---
### 总结

- DHCP 协议主要是用来给客户租用 IP 地址，和房产中介很像，要商谈、签约、续租，广播还不能“抢单”；
- DHCP 协议能给客户推荐“装修队”PXE，能够安装操作系统，这个在云计算领域大有用处。

---
## 5.物理层与MAC层

---
### 第一层（物理层）

- 网线
- hub（集线器）

---
### 第二层（数据链路层，MAC 层）

Medium Access Control，即媒体访问控制

- 这个包是发给谁的？谁应该接收？
  - 包的格式
    - MAC 地址
    - 类型
    - 内容
    - CRC
  - 获取MAC
    - ARP
- 大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？
  - 多路访问
    - 信道划分
    - 轮流协议
    - 随机接入协议
- 如果发送的时候出现了错误，怎么办？

---
### 局域网

- 二层设备：交换机
  - 转发表

---
### 总结

- 第一，MAC 层是用来解决多路访问的堵车问题的；
- 第二，ARP 是通过吼的方式来寻找目标 MAC 地址的，吼完之后记住一段时间，这个叫作缓存；
- 第三，交换机是有 MAC 地址学习能力的，学完了它就知道谁在哪儿了，不用广播了。

---
## 6.交换机与VLAN

---
### 计算机网络拓扑的形成

ARP协议

---
### 环路问题

STP

---
### 广播和安全问题

- 物理隔离
- 虚拟隔离
  - VLAN
    - 给交换机网口分配tag
    - tag在MAC头
    - tag有12位，分4096个

---
### 总结

- 当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用 STP 协议，通过华山论剑比武的方式，将有环路的图变成没有环路的树，从而解决环路问题。
- 交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题

---
## 7.ICMP与ping

---
### ICMP协议的格式

内容在IP包里面。

最常用的类型：主动请求8，主动请求应答0。

---
### 查询报文类型

- ping
  - ICMP ECHO REQUEST
  - ICMP ECHO REPLY
  
---
### 差错报文类型

- 终点不可达3
- 源抑制4
- 重定向5
- 超时11
- 会携带出错IP包的IP头和正文前8字节

---
### ping,ICMP的使用

查询报文的使用

- ICMP ECHO REQUEST
- ICMP ECHO REPLY

---
### Traceroute：差错报文的使用

- 设置递增的TTL
- 设置不分片，固定最大MTU

---
### 总结

- ICMP 相当于网络世界的侦察兵。我讲了两种类型的 ICMP 报文，一种是主动探查的查询报文，一种异常报告的差错报文；
- ping 使用查询报文，Traceroute 使用差错报文。

---
## 8.静态路由、转发网管和NAT网关
---
### 网关

- 网关往往是一个路由器，是一个三层转发的设备。啥叫三层设备？前面也说过了，就是把 MAC 头和 IP 头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。
- 很多情况下，人们把网关就叫作路由器。其实不完全准确，而另一种比喻更加恰当：路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的 IP 地址都和局域网的 IP 地址相同的网段，每只手都是它握住的那个局域网的网关。
- 任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下 MAC 头和 IP 头，看看，根据自己的路由算法，选择另一只手，加上 IP 头和 MAC 头，然后扔出去。

---
### 静态路由

- 转发的选择
  - 动态路由
  - 静态路由
    - 静态路由，其实就是在路由器上，配置一条一条规则。

---
### 网关分类

- 转发网关
- NAT网关
  - Network Address Translation
  - 主机+端口映射

---
### 总结

- 如果离开本局域网，就需要经过网关，网关是路由器的一个网口；
- 路由器是一个三层设备，里面有如何寻找下一跳的规则；
- 经过路由器之后 MAC 头要变，如果 IP 不变，相当于不换护照的欧洲旅游，如果 IP 变，相当于换护照的玄奘西行。最后，给你留两个思考题吧。

---
## 9.路由协议

---
### 配置路由
---
#### 静态路由

- 路由表
  - 目标地址
  - 出口设备
  - 下一跳网关
  - 核心：根据目的 IP 地址来配置路由
- 策略路由
  - 可以配置多个路由表，可以根据源 IP 地址、入口设备、TOS 等选择路由表，然后在路由表中查找路由。这样可以使得来自不同来源的包走不同的路由。

---
#### 动态路由

使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。

- 距离矢量路由算法
  - 算法：Bellman-Ford
  - 具体
    - 每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居，每个路由器也能从邻居那里得到相似的信息。每个路由器根据新收集的信息，计算和其他路由器的距离，比如自己的一个邻居距离目标路由器的距离是 M，而自己距离邻居是 x，则自己距离目标路由器是 x+M。
  - 问题
    - 好消息传得快，坏消息传得慢
    - 每次发送的时候，要发送整个全局路由表
- 链路状态路由算法
  - 算法：Dijkstra
  - 具体
    - 每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径

---
### 动态路由协议

-  基于链路状态路由算法的 OSPF
   -  OSPF（Open Shortest Path First，开放式最短路径优先）
   -  内部网关协议（Interior Gateway Protocol，简称 IGP）
   -  等价路由（负载均衡）
-  基于距离矢量路由算法的 BGP
   -  外网路由协议（Border Gateway Protocol，简称 BGP）
   -  数据中心的Policy，有些包不能转发
   -  AS（Autonomous System）
      -  分类
        -  Stub AS：对外只有一个连接。这类 AS 不会传输其他 AS 的包。例如，个人或者小公司的网络。
        -  Multihomed AS：可能有多个连接连到其他的 AS，但是大多拒绝帮其他的 AS 传输包。例如一些大公司的网络。
        -  Transit AS：有多个连接连到其他的 AS，并且可以帮助其他的 AS 传输包。例如主干网。
      - 每个自治系统都有边界路由器，通过它和外面的世界建立联系。
   - 分类
     - eBGP
       - 边界路由器之间使用 eBGP 广播路由
     - iBGP
       - 边界路由器如何将 BGP 学习到的路由导入到内部网络呢？就是通过运行 iBGP，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。
     - 子网比较大，表中内容比较少，规避了距离矢量算法的两个问题

---
### 小结

- 路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；
- 动态路由主流算法有两种，距离矢量算法和链路状态算法。基于两种算法产生两种协议，BGP 协议和 OSPF 协议。

---
## 10.UDP
---
### TCP与UDP的区别

- TCP
  - 面向连接的
    - 建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性
  - TCP 提供可靠交付
  - TCP 是面向字节流的
  - TCP 是可以有拥塞控制的
  - 因而 TCP 其实是一个有状态服务
- UDP
  - 无连接的
  - UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达
  - 基于数据报的，一个一个地发，一个一个地收
  - UDP 就不会，应用让我发，我就发
  - UDP 则是无状态服务

我们可以这样比喻，如果 MAC 层定义了本地局域网的传输行为，IP 层定义了整个网络端到端的传输行为，这两层基本定义了这样的基因：**网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。我们笼统地称为包。包单独传输，自行选路，在不同的设备封装解封装，不保证到达**。基于这个基因，生下来的孩子 UDP 完全继承了这些特性，几乎没有自己的思想。

---
### UDP
---
#### 包头

- IP头中有一个8位协议
  - TCP
  - UDP
- UDP头
  - 源端口号-16
  - 目标端口号-16
  - UDP长度-16
  - UDP校验和-16
  - 数据

---
#### 三大特点

- 沟通简单
  - 设定少
  - 处理逻辑简单
- 轻信他人
  - 不建立连接
- 不权变
  - 不拥塞控制

---
#### 三大使用场景

- 资源少，网络好，或者丢包不敏感
  - DHCP（内网）
  - PXE种的TFTP（客户端无OS，资源少，维护不了TCP）
  - 流媒体（丢包不敏感）
- 不需要连接，可以广播使用
  - DHCP
  - 组播地址-IGMP
  - 云服务-VXLAN
- 时延低，网络拥塞时也不减速
  - 流媒体
  - 实时游戏

---
### UDP的5个例子

- QUIC
  - 网页，APP的访问
- 流媒体协议
  - 丢包无意义
- 实时游戏
  - 接受不了延迟
- IoT物联网
  - TCP太耗资源
- 移动通信
  - 4G的GTP-U

---
### 小结

- 如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；TCP 维护连接，UDP 谁都相信；TCP 会坚持知进退；UDP 愣头青一个，勇往直前；
- UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。

---
## 11.TCP连接

---
### 包头

- 源端口号-16
- 目标端口号-16
- 序号-32
- 确认序号-32
- 首部长度-4
- 保留-6
- 状态位-6
- 窗口大小-16
- 校验和-16
- 紧急指针-16
- 选项
- 数据

---
### 要解决的问题

- 顺序问题
- 丢包问题
- 连接维护
- 流量控制
- 拥塞控制

---
### 三次握手

![三次握手](.\pic\计算机网络\TCP\三次握手.jpg)

- 连接维护的问题
  - 三次握手
    - 目的1-建立连接
      - 请求
      - 应答
      - 应答之应答
    - 目的2-TCP 包的序号的问题
  - keepalive-探活包


---
### 四次挥手

![四次挥手](.\pic\计算机网络\TCP\四次挥手.jpg)

等待的时间设为 2MSL，MSL 是 Maximum Segment Lifetime，报文最大生存时间

---
### TCP状态机

![TCP状态机](.\pic\计算机网络\TCP\TCP状态机.jpg)

---
### 小结

- TCP 包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制；
- 连接的建立是经过三次握手，断开的时候四次挥手，一定要掌握的我画的那个状态图。

---
## 12.TCP策略

### 编号

给每个包编个号

### 接收端、发送端数据结构

累计应答（cumulative acknowledgment）


![数据结构1](.\pic\计算机网络\TCP\数据结构1.jpg)

- 四个部分
  - 发送了并且已经确认的
  - 发送了并且尚未确认的
  - 没有发送，但是已经等待发送的
  - 没有发送，并且暂时还不会发送的
- 发送端数据结构
  - LastByteAcked：第一部分和第二部分的分界线
  - LastByteSent：第二部分和第三部分的分界线
  - LastByteAcked + AdvertisedWindow：第三部分和第四部分的分界线

![数据结构2](.\pic\计算机网络\TCP\数据结构2.jpg)

- 三个部分
  - 接受并且确认过的
  - 还没接收，但是马上就能接收的
  - 还没接收，也没法接收的
- 接收端数据结构
  - MaxRcvBuffer：最大缓存的量；
  - LastByteRead 之后是已经接收了，但是还没被应用层读取的；
  - NextByteExpected 是第一部分和第二部分的分界线。

### 顺序问题与丢包问题

- 确认与重发的机制
  - 超时重试
    - 往返时间 RTT
    - 用RTT估计超时时间
      - 自适应重传算法（Adaptive Retransmission Algorithm）
    - 超时间隔加倍
      - 每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送
  - 快速重传的机制
      - 发送三个冗余的 ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段
  - Selective Acknowledgment  （SACK）
    - 这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。例如可以发送 ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是 7 丢了。

### 流量控制

- 根据数据处理情况，修改窗口的大小。
- 在为0时，发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小

### 拥塞问题

通过窗口的大小来控制的，前面的滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满。

LastByteSent - LastByteAcked <= min {cwnd, rwnd}

- 目的
  - 避免包丢失
  - 避免超时重传

#### 慢启动

一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd 加一，于是一次能够发送两个；当这两个的确认到来的时候，每个确认 cwnd 加一，两个确认 cwnd 加二，于是一次能够发送四个；当这四个的确认到来的时候，每个确认 cwnd 加一，四个确认 cwnd 加四，于是一次能够发送八个。可以看出这是指数性的增长。

涨到什么时候是个头呢？有一个值 ssthresh 为 65535 个字节，当超过这个值的时候，就要小心一点了，不能倒这么快了，可能快满了，再慢下来。

每收到一个确认后，cwnd 增加 1/cwnd，我们接着上面的过程来，一次发送八个，当八个确认到来的时候，每个确认增加 1/8，八个确认一共 cwnd 增加 1，于是一次能够发送九个，变成了线性增长。

但是线性增长还是增长，还是越来越多，直到有一天，水满则溢，出现了拥塞，这时候一般就会一下子降低倒水的速度，等待溢出的水慢慢渗下去。

拥塞的一种表现形式是丢包，需要超时重传，这个时候，将 sshresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动。这真是一旦超时重传，马上回到解放前。但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。

- 两个问题
  - 第一个问题是丢包并不代表着通道满了，也可能是管子本来就漏水（公网丢包）
  - 第二个问题是 TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了
- 解决方法
  -  TCP BBR 拥塞算法

![BBR](.\pic\计算机网络\TCP\BBR.jpg)

### 小结

- 顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的，这其实就相当于你领导和你的工作备忘录，布置过的工作要有编号，干完了有反馈，活不能派太多，也不能太少；
- 拥塞控制是通过拥塞窗口来解决的，相当于往管道里面倒水，快了容易溢出，慢了浪费带宽，要摸着石头过河，找到最优值。



---
## 13.Socket编程

### 基于 TCP 协议的 Socket 程序函数调用过程

### 基于 UDP 协议的 Socket 程序函数调用过程

### 服务器提供多个服务




### 小结

- 你需要记住 TCP 和 UDP 的 Socket 的编程中，客户端和服务端都需要调用哪些函数；
- 写一个能够支撑大量连接的高并发的服务端不容易，需要多进程、多线程，而 epoll 机制能解决 C10K 问题。

---
## 14.HTTP
---
### HTTP 请求的准备

- URL
- DNS解析
- 基于TCP
  - 三次握手

---
### HTTP 请求的构建

- 请求行
  - 方法
  - URL
  - 版本
- 首部
  - key value
  - key value
  - key value
  - ...
- 实体

---
#### 请求行

- URL
  - www.baidu.com
- 版本
- HTTP 1.1
- 方法
  - GET
  - POST
  - PUT
  - DELETE

---
#### 首部

- Accept-Charset
  - 字符集
  - utf-8
- Content-Tpye
  - 正文格式
  - json
- Cache-control
  - 控制缓存
  - max-age
- If-Modified-Since

---
#### 缓存

- Nginx
  - Varnish（静态资源）
  - Redis（动态资源）
- Tomcat

**应用层**到**传输层**，socket编程，浏览器完成。

---
### HTTP 请求的发送

- HTTP
- TCP
- 丢包重传
- IP
- ARP
- MAC
- ...
- MAC
- IP
- TCP
  - 查看序列号
- 发送到HTTP服务器端口

---
### HTTP 返回的构建

- 状态行
  - 版本
  - 状态码
  - 短语
- 首部
  - key value
  - key value
  - key value
  - ...
- 实体

---
#### 首部

- Retry-After
  - 告诉客户端应该在多长时间以后再次尝试一下
- Content-Type
  - HTML
  - json

---
#### HTTP 返回发送

- 应用层数据
- TCP
- 丢包重传
- IP
- ARP
- MAC
- ...
- MAC
- IP
- TCP
  - 查看序列号
- 发送到HTTP服务器端口

---
### HTTP 2.0

- 头部压缩
- 两种机制
  - TCP分流
  - 传输消息分帧
- 效果
  - 可以乱序发送
  - HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题
  - 减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。

---
### QUIC 协议

HTTP2是基于TCP的，无法避免一些TCP的机制问题。

- 自定义连接机制
  - 在 QUIC 自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个 64 位的随机数作为 ID 来标识，而且 UDP 是无连接的，所以当 IP 或者端口变化的时候，只要 ID 不变，就不需要重新建立连接
- 自定义重传机制
  - QUIC 也有个序列号，是递增的。任何一个序列号的包只发送一次，下次就要加一了。例如，发送一个包，序号是 100，发现没有返回；再次发送的时候，序号就是 101 了；如果返回的 ACK  100，就是对第一个包的响应。如果返回 ACK  101 就是对第二个包的响应，RTT 计算相对准确
  - offset
- 无阻塞的多路复用
  - 可以解决上面 HTTP  2.0 的多路复用问题。同 HTTP 2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求。但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖。这样，假如 stream2 丢了一个 UDP 包，后面跟着 stream3 的一个 UDP 包，虽然 stream2 的那个包需要重传，但是 stream3 的包无需等待，就可以发给用户
- 自定义流量控制
  - QUIC 的 ACK 是基于 offset 的，每个 offset 的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空挡会等待到来或者重发即可，而窗口的起始位置为当前收到的最大 offset，从这个 offset 到当前的 stream 所能容纳的最大缓存，是真正的窗口大小。显然，这样更加准确。 

---
### 小结

- HTTP 协议虽然很常用，也很复杂，重点记住 GET、POST、 PUT、DELETE 这几个方法，以及重要的首部字段；
- HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能；
- QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。

---
## 15.HTTPS


---
## 16.流媒体协议


---
## 17.P2P



---
## 18.DNS



---
## 19.HTTPDNS



---
## 20.CDN




---
## 21.数据中心


---
## 22.VPN


---
## 23.移动网络


---