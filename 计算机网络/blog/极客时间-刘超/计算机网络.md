# 计算机网络

- [1.网络协议](#1.网络协议)
- [2.网络分层](#2.网络分层)
- [3.ifconfig:ip](#3.ifconfig:ip)
- [4.DHCP与PXE](#4.DHCP与PXE)
- [5.物理层与MAC层](#5.物理层与MAC层)
- [6.交换机与VLAN（STP，VLAN）](#6.交换机与VLAN)
- [7.ICMP与ping](#7.ICMP与ping)
- [8.静态路由、转发网管和NAT网关](#8.静态路由、转发网管和NAT网关)
- [9.动态路由](#9.动态路由)
- [10.UDP](#10.UDP)
- [11.TCP连接](#11.TCP连接)
- [12.TCP策略](#12.TCP策略)
- [13.socket编程](#13.socket编程)
- [14.HTTP](#14.HTTP)
- [15.HTTPS](#15.HTTPS)
- [16.流媒体协议](#16.流媒体协议)
- [17.P2P](#17.P2P)
- [18.DNS](#18.DNS)
- [19.HTTPDNS](#19.HTTPDNS)
- [20.CDN](#20.CDN)
- [21.数据中心](#21.数据中心)
- [22.VPN](#22.VPN)
- [23.移动网络](#23.移动网络)



## 1.网络协议

---
### 协议的三要素

- 语法
  - 状态
  - 首部
  - 内容
- 语义
  - 200
  - 404
- 顺序
  - 发送
  - 接收

---
### 常用的网络协议

- 应用层
  - 输入URL
    - DNS
    - HTTPDNS
  - 获得IP
  - 发送请求
    - HTTP
    - HTTPS
- 传输层
  - UDP
  - TCP
- 网络层
  - IP
  - 路由协议
    - OSPF
    - BGP
  - ICMP
  - IPSec
  - GRE
- MAC层
  - ARP
    - 获得MAC
  - VLAN
  - STP
- 服务器端
  - Tomcat
  - RPC

---
## 2.网络分层

---
### 网络问什么要分层

复杂的程序都要分层

---
### 处理网络包的程序如何工作

- process_layer2(buffer)
- process_layer3(buffer)
- process_tcp(buffer)
- 浏览器
- send_tcp(buffer)
- send_layer3(buffer)
- send_layer2(buffer)

---
### 层与层之间的关系

在网络中的包都是完整的，一定有底层的mac和ip

---
### 总结

- 始终想象自己是一个处理网络包的程序：如何拿到网络包，如何根据规则进行处理，如何发出去；
- 始终牢记一个原则：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。

---
## 3.ifconfig:ip

---
### 查看ip的指令

- Windows
  - ipconfig
- Linux
  - ifconfig
  - ip addr
    - IPV4
      - 10.100.122.2
    - IPV6
      - inet6 fe80::f816:3eff:fec7:7975/64
    - scope
      - global
      - host
    - lo
      - loopback
      - 127.0.0.1
    - mac
      - link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff
    - <BROADCAST,MULTICAST,UP,LOWER_UP>
      - net_device flags，网络设备的状态标识
    - 最大传输单元 MTU 为 1500，这是以太网的默认值
    - qdisc pfifo_fast
      - queueing discipline，中文叫排队规则
      - pfifo
      - pfifo_fast 
        - band 0
        - band 1
        - band 2
      - TOS（Type of Service）
        - IP头中，会分配到对应波段
- ABCDE5类ip

---
### 无类型域间选路（CIDR）

- 广播地址
- 子网掩码

---
### 举例：一个容易“犯错”的 CIDR

- IP：16.158.165.91/22
- 网络号：16.158.<101001>
- 机器号：<01>.91
- 第一个地址：16.158.<101001><00>.1；16.158.164.1
- 广播地址：16.158.<101001><11>.255；16.158.167.255

---
### 总结

- IP 是地址，有定位功能；MAC 是身份证，无定位功能；
- CIDR 可以用来判断是不是本地人；
- IP 分公有的 IP 和私有的 IP。后面的章节中我会谈到“出国门”，就与这个有关。

---
## 4.DHCP与PXE

---
### 如何配置IP

- net-tools
  - ifconfig
- iproute2
  - ip addr

Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。

不同系统的配置文件格式不同，但是无非就是 CIDR、子网掩码、广播地址和网关地址。

---
### 动态主机配置协议（DHCP）

如果是数据中心里面的服务器，IP 一旦配置好，基本不会变，这就相当于买房自己装修。DHCP 的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。

--- 
### 解析 DHCP 的工作方式

- DHCP Discover
  - 新来的机器使用 IP 地址 0.0.0.0 发送了一个广播包，目的 IP 地址为 255.255.255.255。广播包封装了 UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版，但是如果你去抓包的话，很可能看到的名称还是 BOOTP 协议。
- DHCP Offer
  - DHCP Server 仍然使用广播地址作为目的地址，因为，此时请求分配 IP 的新人还没有自己的 IP。DHCP Server 回复说，我分配了一个可用的 IP 给你，你看如何？除此之外，服务器还发送了子网掩码、网关和 IP 地址租用期等信息。
- 客户端
  - 客户端仍然使用 0.0.0.0 为源 IP 地址、255.255.255.255 为目标地址进行广播。
- DHCP Server
  - 当 DHCP Server 接收到客户机的 DHCP request 之后，会广播返回给客户机一个 DHCP ACK 消息包，表明已经接受客户机的选择，并将这一 IP 地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机，欢迎它加入网络大家庭。

---
### IP 地址的收回和续租

客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP request 消息包。客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及其他已经更新的 TCP/IP 参数，更新自己的配置。这样，IP 租用更新就完成了。

---
### 预启动执行环境（PXE）

Pre-boot Execution Environment

- PXE 协议分为客户端和服务器端
- 客户端
  - BIOS里面
- 服务器端

---
### 解析 PXE 的工作过程

首先，启动 PXE 客户端。第一步是通过 DHCP 协议告诉 DHCP Server，我刚来，一穷二白，啥都没有。DHCP Server 便租给它一个 IP 地址，同时也给它 PXE 服务器的地址、启动文件 pxelinux.0。

其次，PXE 客户端知道要去 PXE 服务器下载这个文件后，就可以初始化机器。于是便开始下载，下载的时候使用的是 TFTP 协议。所以 PXE 服务器上，往往还需要有一个 TFTP 服务器。PXE 客户端向 TFTP 服务器请求下载这个文件，TFTP 服务器说好啊，于是就将这个文件传给它。

然后，PXE 客户端收到这个文件后，就开始执行这个文件。这个文件会指示 PXE 客户端，向 TFTP 服务器请求计算机的配置信息 pxelinux.cfg。TFTP 服务器会给 PXE 客户端一个配置文件，里面会说内核在哪里、initramfs 在哪里。PXE 客户端会请求这些文件。

最后，启动 Linux 内核。一旦启动了操作系统，以后就啥都好办了。

---
### 总结

- DHCP 协议主要是用来给客户租用 IP 地址，和房产中介很像，要商谈、签约、续租，广播还不能“抢单”；
- DHCP 协议能给客户推荐“装修队”PXE，能够安装操作系统，这个在云计算领域大有用处。

---
## 5.物理层与MAC层

---
### 第一层（物理层）

- 网线
- hub（集线器）

---
### 第二层（数据链路层，MAC 层）

Medium Access Control，即媒体访问控制

- 这个包是发给谁的？谁应该接收？
  - 包的格式
    - MAC 地址
    - 类型
    - 内容
    - CRC
  - 获取MAC
    - ARP
- 大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？
  - 多路访问
    - 信道划分
    - 轮流协议
    - 随机接入协议
- 如果发送的时候出现了错误，怎么办？

---
### 局域网

- 二层设备：交换机
  - 转发表

---
### 总结

- 第一，MAC 层是用来解决多路访问的堵车问题的；
- 第二，ARP 是通过吼的方式来寻找目标 MAC 地址的，吼完之后记住一段时间，这个叫作缓存；
- 第三，交换机是有 MAC 地址学习能力的，学完了它就知道谁在哪儿了，不用广播了。

---
## 6.交换机与VLAN

---
### 计算机网络拓扑的形成

ARP协议

---
### 环路问题

STP

---
### 广播和安全问题

- 物理隔离
- 虚拟隔离
  - VLAN
    - 给交换机网口分配tag
    - tag在MAC头
    - tag有12位，分4096个

---
### 总结

- 当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用 STP 协议，通过华山论剑比武的方式，将有环路的图变成没有环路的树，从而解决环路问题。
- 交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题

---
## 7.ICMP与ping

---
### ICMP协议的格式

内容在IP包里面。

最常用的类型：主动请求8，主动请求应答0。

---
### 查询报文类型

- ping
  - ICMP ECHO REQUEST
  - ICMP ECHO REPLY
  
---
### 差错报文类型

- 终点不可达3
- 源抑制4
- 重定向5
- 超时11
- 会携带出错IP包的IP头和正文前8字节

---
### ping,ICMP的使用

查询报文的使用

- ICMP ECHO REQUEST
- ICMP ECHO REPLY

---
### Traceroute：差错报文的使用

- 设置递增的TTL
- 设置不分片，固定最大MTU

---
### 总结

- ICMP 相当于网络世界的侦察兵。我讲了两种类型的 ICMP 报文，一种是主动探查的查询报文，一种异常报告的差错报文；
- ping 使用查询报文，Traceroute 使用差错报文。

---
## 8.静态路由、转发网管和NAT网关
---
### 网关

- 网关往往是一个路由器，是一个三层转发的设备。啥叫三层设备？前面也说过了，就是把 MAC 头和 IP 头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。
- 很多情况下，人们把网关就叫作路由器。其实不完全准确，而另一种比喻更加恰当：路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的 IP 地址都和局域网的 IP 地址相同的网段，每只手都是它握住的那个局域网的网关。
- 任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下 MAC 头和 IP 头，看看，根据自己的路由算法，选择另一只手，加上 IP 头和 MAC 头，然后扔出去。

---
### 静态路由

- 转发的选择
  - 动态路由
  - 静态路由
    - 静态路由，其实就是在路由器上，配置一条一条规则。

---
### 网关分类

- 转发网关
- NAT网关
  - Network Address Translation
  - 主机+端口映射

---
### 总结

- 如果离开本局域网，就需要经过网关，网关是路由器的一个网口；
- 路由器是一个三层设备，里面有如何寻找下一跳的规则；
- 经过路由器之后 MAC 头要变，如果 IP 不变，相当于不换护照的欧洲旅游，如果 IP 变，相当于换护照的玄奘西行。最后，给你留两个思考题吧。

---
## 9.路由协议

---
### 配置路由
---
#### 静态路由

- 路由表
  - 目标地址
  - 出口设备
  - 下一跳网关
  - 核心：根据目的 IP 地址来配置路由
- 策略路由
  - 可以配置多个路由表，可以根据源 IP 地址、入口设备、TOS 等选择路由表，然后在路由表中查找路由。这样可以使得来自不同来源的包走不同的路由。

---
#### 动态路由

使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。

- 距离矢量路由算法
  - 算法：Bellman-Ford
  - 具体
    - 每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居，每个路由器也能从邻居那里得到相似的信息。每个路由器根据新收集的信息，计算和其他路由器的距离，比如自己的一个邻居距离目标路由器的距离是 M，而自己距离邻居是 x，则自己距离目标路由器是 x+M。
  - 问题
    - 好消息传得快，坏消息传得慢
    - 每次发送的时候，要发送整个全局路由表
- 链路状态路由算法
  - 算法：Dijkstra
  - 具体
    - 每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径

---
### 动态路由协议

-  基于链路状态路由算法的 OSPF
   -  OSPF（Open Shortest Path First，开放式最短路径优先）
   -  内部网关协议（Interior Gateway Protocol，简称 IGP）
   -  等价路由（负载均衡）
-  基于距离矢量路由算法的 BGP
   -  外网路由协议（Border Gateway Protocol，简称 BGP）
   -  数据中心的Policy，有些包不能转发
   -  AS（Autonomous System）
      -  分类
        -  Stub AS：对外只有一个连接。这类 AS 不会传输其他 AS 的包。例如，个人或者小公司的网络。
        -  Multihomed AS：可能有多个连接连到其他的 AS，但是大多拒绝帮其他的 AS 传输包。例如一些大公司的网络。
        -  Transit AS：有多个连接连到其他的 AS，并且可以帮助其他的 AS 传输包。例如主干网。
      - 每个自治系统都有边界路由器，通过它和外面的世界建立联系。
   - 分类
     - eBGP
       - 边界路由器之间使用 eBGP 广播路由
     - iBGP
       - 边界路由器如何将 BGP 学习到的路由导入到内部网络呢？就是通过运行 iBGP，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。
     - 子网比较大，表中内容比较少，规避了距离矢量算法的两个问题

---
### 小结

- 路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；
- 动态路由主流算法有两种，距离矢量算法和链路状态算法。基于两种算法产生两种协议，BGP 协议和 OSPF 协议。

---
## 10.UDP
---
### TCP与UDP的区别

- TCP
  - 面向连接的
    - 建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性
  - TCP 提供可靠交付
  - TCP 是面向字节流的
  - TCP 是可以有拥塞控制的
  - 因而 TCP 其实是一个有状态服务
- UDP
  - 无连接的
  - UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达
  - 基于数据报的，一个一个地发，一个一个地收
  - UDP 就不会，应用让我发，我就发
  - UDP 则是无状态服务

我们可以这样比喻，如果 MAC 层定义了本地局域网的传输行为，IP 层定义了整个网络端到端的传输行为，这两层基本定义了这样的基因：**网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。我们笼统地称为包。包单独传输，自行选路，在不同的设备封装解封装，不保证到达**。基于这个基因，生下来的孩子 UDP 完全继承了这些特性，几乎没有自己的思想。

---
### UDP
---
#### 包头

- IP头中有一个8位协议
  - TCP
  - UDP
- UDP头
  - 源端口号-16
  - 目标端口号-16
  - UDP长度-16
  - UDP校验和-16
  - 数据

---
#### 三大特点

- 沟通简单
  - 设定少
  - 处理逻辑简单
- 轻信他人
  - 不建立连接
- 不权变
  - 不拥塞控制

---
#### 三大使用场景

- 资源少，网络好，或者丢包不敏感
  - DHCP（内网）
  - PXE种的TFTP（客户端无OS，资源少，维护不了TCP）
  - 流媒体（丢包不敏感）
- 不需要连接，可以广播使用
  - DHCP
  - 组播地址-IGMP
  - 云服务-VXLAN
- 时延低，网络拥塞时也不减速
  - 流媒体
  - 实时游戏

---
### UDP的5个例子

- QUIC
  - 网页，APP的访问
- 流媒体协议
  - 丢包无意义
- 实时游戏
  - 接受不了延迟
- IoT物联网
  - TCP太耗资源
- 移动通信
  - 4G的GTP-U

---
### 小结

- 如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；TCP 维护连接，UDP 谁都相信；TCP 会坚持知进退；UDP 愣头青一个，勇往直前；
- UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。

---
## 11.TCP连接

---
### 包头

- 源端口号-16
- 目标端口号-16
- 序号-32
- 确认序号-32
- 首部长度-4
- 保留-6
- 状态位-6
- 窗口大小-16
- 校验和-16
- 紧急指针-16
- 选项
- 数据

---
### 要解决的问题

- 顺序问题
- 丢包问题
- 连接维护
- 流量控制
- 拥塞控制

---
### 三次握手

![三次握手](.\pic\计算机网络\TCP\三次握手.jpg)

- 连接维护的问题
  - 三次握手
    - 目的1-建立连接
      - 请求
      - 应答
      - 应答之应答
    - 目的2-TCP 包的序号的问题
  - keepalive-探活包


---
### 四次挥手

![四次挥手](.\pic\计算机网络\TCP\四次挥手.jpg)

等待的时间设为 2MSL，MSL 是 Maximum Segment Lifetime，报文最大生存时间

---
### TCP状态机

![TCP状态机](.\pic\计算机网络\TCP\TCP状态机.jpg)

---
### 小结

- TCP 包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制；
- 连接的建立是经过三次握手，断开的时候四次挥手，一定要掌握的我画的那个状态图。

---
## 12.TCP策略

### 编号

给每个包编个号

### 接收端、发送端数据结构

累计应答（cumulative acknowledgment）


![数据结构1](.\pic\计算机网络\TCP\数据结构1.jpg)

- 四个部分
  - 发送了并且已经确认的
  - 发送了并且尚未确认的
  - 没有发送，但是已经等待发送的
  - 没有发送，并且暂时还不会发送的
- 发送端数据结构
  - LastByteAcked：第一部分和第二部分的分界线
  - LastByteSent：第二部分和第三部分的分界线
  - LastByteAcked + AdvertisedWindow：第三部分和第四部分的分界线

![数据结构2](.\pic\计算机网络\TCP\数据结构2.jpg)

- 三个部分
  - 接受并且确认过的
  - 还没接收，但是马上就能接收的
  - 还没接收，也没法接收的
- 接收端数据结构
  - MaxRcvBuffer：最大缓存的量；
  - LastByteRead 之后是已经接收了，但是还没被应用层读取的；
  - NextByteExpected 是第一部分和第二部分的分界线。

### 顺序问题与丢包问题

- 确认与重发的机制
  - 超时重试
    - 往返时间 RTT
    - 用RTT估计超时时间
      - 自适应重传算法（Adaptive Retransmission Algorithm）
    - 超时间隔加倍
      - 每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送
  - 快速重传的机制
      - 发送三个冗余的 ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段
  - Selective Acknowledgment  （SACK）
    - 这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。例如可以发送 ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是 7 丢了。

### 流量控制

- 根据数据处理情况，修改窗口的大小。
- 在为0时，发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小

### 拥塞问题

通过窗口的大小来控制的，前面的滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满。

LastByteSent - LastByteAcked <= min {cwnd, rwnd}

- 目的
  - 避免包丢失
  - 避免超时重传

#### 慢启动

一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd 加一，于是一次能够发送两个；当这两个的确认到来的时候，每个确认 cwnd 加一，两个确认 cwnd 加二，于是一次能够发送四个；当这四个的确认到来的时候，每个确认 cwnd 加一，四个确认 cwnd 加四，于是一次能够发送八个。可以看出这是指数性的增长。

涨到什么时候是个头呢？有一个值 ssthresh 为 65535 个字节，当超过这个值的时候，就要小心一点了，不能倒这么快了，可能快满了，再慢下来。

每收到一个确认后，cwnd 增加 1/cwnd，我们接着上面的过程来，一次发送八个，当八个确认到来的时候，每个确认增加 1/8，八个确认一共 cwnd 增加 1，于是一次能够发送九个，变成了线性增长。

但是线性增长还是增长，还是越来越多，直到有一天，水满则溢，出现了拥塞，这时候一般就会一下子降低倒水的速度，等待溢出的水慢慢渗下去。

拥塞的一种表现形式是丢包，需要超时重传，这个时候，将 sshresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动。这真是一旦超时重传，马上回到解放前。但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。

- 两个问题
  - 第一个问题是丢包并不代表着通道满了，也可能是管子本来就漏水（公网丢包）
  - 第二个问题是 TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了
- 解决方法
  -  TCP BBR 拥塞算法

![BBR](.\pic\计算机网络\TCP\BBR.jpg)

### 小结

- 顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的，这其实就相当于你领导和你的工作备忘录，布置过的工作要有编号，干完了有反馈，活不能派太多，也不能太少；
- 拥塞控制是通过拥塞窗口来解决的，相当于往管道里面倒水，快了容易溢出，慢了浪费带宽，要摸着石头过河，找到最优值。



---
## 13.Socket编程

在网络层，Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。另外，还要指定到底是 TCP 还是 UDP。还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM

### 基于 TCP 协议的 Socket 程序函数调用过程

- 服务端
  - 调用bind函数，给Socket赋予IP地址和端口
  - 调用Listen函数进行监听，这是进入了TCP的listne状态，此时客户端就可以连接了
  - 内核种为每个Socket维护两个队列
    - 已经建立连接的队列
      - 三次握手已经结束
      - established
    - 没有完全建立连接的队列
      - 三次握手没有结束
      - syn_rcvd
  - 调用accept函数，拿出已经完成的连接进行处理，此时没有完成连接的就要等待
  - 服务端等待时，客户端可以通过connect函数发起连接，在参数种指明要连接的IP地址和端口，发起三次握手，内核会给客户端分配临时端口，一旦握手成功，服务器发起的accept就hi返回另一个Socket
  - 注意
    - 监听的Socket和真正用来传输数据的Socket是两个
      - 监听Socket
      - 已连接Socket
  - 建立连接后，双方通过read和write函数来读写数据

![TCPsocket.jpg](.\pic\计算机网络\Socket\TCPsocket.jpg)

- 进程
  - task_struct
    - 文件描述符数组
      - 文件描述符：数组下标
      - 数组中的内容是指向内核打开文件的列表
      - 列表中保存着inode
      - inode指向内核中的Socket结构
      - Socket结构中主要有两个队列
        - 发送队列
        - 接受队列

![socket结构.jpg](.\pic\计算机网络\Socket\socket结构.jpg)


### 基于 UDP 协议的 Socket 程序函数调用过程

![UDPsocket.jpg](.\pic\计算机网络\Socket\UDPsocket.jpg)


### 服务器提供多个服务

- 多进程
- 多线程
- IO多路复用，一个线程维护多个Socket
- IO多路复用，epoll

C10K问题

### 小结

- 你需要记住 TCP 和 UDP 的 Socket 的编程中，客户端和服务端都需要调用哪些函数；
- 写一个能够支撑大量连接的高并发的服务端不容易，需要多进程、多线程，而 epoll 机制能解决 C10K 问题。

---
## 14.HTTP
---
### HTTP 请求的准备

- URL
- DNS解析
- 基于TCP
  - 三次握手

---
### HTTP 请求的构建

- 请求行
  - 方法
  - URL
  - 版本
- 首部
  - key value
  - key value
  - key value
  - ...
- 实体

---
#### 请求行

- URL
  - www.baidu.com
- 版本
- HTTP 1.1
- 方法
  - GET
  - POST
  - PUT
  - DELETE

---
#### 首部

- Accept-Charset
  - 字符集
  - utf-8
- Content-Tpye
  - 正文格式
  - json
- Cache-control
  - 控制缓存
  - max-age
- If-Modified-Since

---
#### 缓存

- Nginx
  - Varnish（静态资源）
  - Redis（动态资源）
- Tomcat

**应用层**到**传输层**，socket编程，浏览器完成。

---
### HTTP 请求的发送

- HTTP
- TCP
- 丢包重传
- IP
- ARP
- MAC
- ...
- MAC
- IP
- TCP
  - 查看序列号
- 发送到HTTP服务器端口

---
### HTTP 返回的构建

- 状态行
  - 版本
  - 状态码
  - 短语
- 首部
  - key value
  - key value
  - key value
  - ...
- 实体

---
#### 首部

- Retry-After
  - 告诉客户端应该在多长时间以后再次尝试一下
- Content-Type
  - HTML
  - json

---
#### HTTP 返回发送

- 应用层数据
- TCP
- 丢包重传
- IP
- ARP
- MAC
- ...
- MAC
- IP
- TCP
  - 查看序列号
- 发送到HTTP服务器端口

---
### HTTP 2.0

- 头部压缩
- 两种机制
  - TCP分流
  - 传输消息分帧
- 效果
  - 可以乱序发送
  - HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题
  - 减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、 jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。

---
### QUIC 协议

HTTP2是基于TCP的，无法避免一些TCP的机制问题。

- 自定义连接机制
  - 在 QUIC 自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个 64 位的随机数作为 ID 来标识，而且 UDP 是无连接的，所以当 IP 或者端口变化的时候，只要 ID 不变，就不需要重新建立连接
- 自定义重传机制
  - QUIC 也有个序列号，是递增的。任何一个序列号的包只发送一次，下次就要加一了。例如，发送一个包，序号是 100，发现没有返回；再次发送的时候，序号就是 101 了；如果返回的 ACK  100，就是对第一个包的响应。如果返回 ACK  101 就是对第二个包的响应，RTT 计算相对准确
  - offset
- 无阻塞的多路复用
  - 可以解决上面 HTTP  2.0 的多路复用问题。同 HTTP 2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求。但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖。这样，假如 stream2 丢了一个 UDP 包，后面跟着 stream3 的一个 UDP 包，虽然 stream2 的那个包需要重传，但是 stream3 的包无需等待，就可以发给用户
- 自定义流量控制
  - QUIC 的 ACK 是基于 offset 的，每个 offset 的包来了，进了缓存，就可以应答，应答后就不会重发，中间的空挡会等待到来或者重发即可，而窗口的起始位置为当前收到的最大 offset，从这个 offset 到当前的 stream 所能容纳的最大缓存，是真正的窗口大小。显然，这样更加准确。 

---
### 小结

- HTTP 协议虽然很常用，也很复杂，重点记住 GET、POST、 PUT、DELETE 这几个方法，以及重要的首部字段；
- HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能；
- QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。

---
## 15.HTTPS

- 加密
  - 对称加密
  - 非对称加密

---
### 对称加密

有交换秘钥的问题

---
### 非对称加密

互相用对方的公钥进行加密，然后用自己的私钥解密

---
### 数字证书

非对称加密公布自己的公钥时，需要数字证书来背书公钥。

- 证书
  - 公钥
  - 公钥所有者
  - 证书发布机构
  - 证书有效期
- 证书权威机构
  - CA（Certificate Authority）
  - 证书前面本身是非对称加密，可以把CA给网站的证书，使用证书的公钥解密
  - 证书的公钥本身会由更高级的CA授权

---
### HTTPS的工作模式

非对称加密在性能上不如对称加密，那是否能将两者结合起来呢？例如，公钥私钥主要用于传输对称加密的秘钥，而真正的双方大数据量的通信都是通过对称加密进行的。

![HTTPS.jpg](.\pic\计算机网络\HTTPS\HTTPS.jpg)

---
### 重放与篡改

有了加密和解密，黑客截获了包也打不开了，但是它可以发送 N 次。这个往往通过 Timestamp 和 Nonce 随机数联合起来，然后做一个不可逆的签名来保证。

Nonce 随机数保证唯一，或者 Timestamp 和 Nonce 合起来保证唯一，同样的，请求只接受一次，于是服务器多次受到相同的 Timestamp 和 Nonce，则视为无效即可。

如果有人想篡改 Timestamp 和 Nonce，还有签名保证不可篡改性，如果改了用签名算法解出来，就对不上了，可以丢弃了。

---
### 小结

- 加密分对称加密和非对称加密。对称加密效率高，但是解决不了密钥传输问题；非对称加密可以解决这个问题，但是效率不高。 
- 非对称加密需要通过证书和权威机构来验证公钥的合法性。
- HTTPS 是综合了对称加密和非对称加密算法的 HTTP 协议。既保证传输安全，也保证传输效率。

---
### 评论精选

- 各大CA机构的公钥是默认安装在操作系统里的。所以不要安装来路不明的操作系统，否则相当于裸奔


---
## 16.流媒体协议

### 三个名词系列

- 名词系列一：AVI、MPEG、RMVB、MP4、MOV、FLV、WebM、WMV、ASF、MKV。例如 RMVB 和 MP4，看着是不是很熟悉？
- 名词系列二：H.261、 H.262、H.263、H.264、H.265。这个是不是就没怎么听过了？别着急，你先记住，要重点关注 H.264。
- 名词系列三：MPEG-1、MPEG-2、MPEG-4、MPEG-7。MPEG 好像听说过，但是后面的数字是怎么回事？是不是又熟悉又陌生？

视频就是快速播放一连串连续的图片。

视频数据量太大，需要编码，编码是一个压缩的过程。

---
### 视频和图片的压缩过程

- 空间冗余：图像的相邻像素之间有较强的相关性，一张图片相邻像素往往是渐变的，不是突变的，没必要每个像素都完整地保存，可以隔几个保存一个，中间的用算法计算出来。
- 时间冗余：视频序列的相邻图像之间内容相似。一个视频中连续出现的图片也不是突变的，可以根据已有的图片进行预测和推断。
- 视觉冗余：人的视觉系统对某些细节不敏感，因此不会每一个细节都注意到，可以允许丢失一些数据。
- 编码冗余：不同像素值出现的概率不同，概率高的用的字节少，概率低的用的字节多，类似霍夫曼编码（Huffman Coding）的思路。

![编码过程.jpg](.\pic\计算机网络\流媒体协议\编码过程.jpg)

---
### 视频编码的两大流派

- 流派一：ITU（International Telecommunications Union）的 VCEG（Video Coding Experts Group），这个称为国际电联下的 VCEG。既然是电信，可想而知，他们最初做视频编码，主要侧重传输。名词系列二，就是这个组织制定的标准。
- 流派二：ISO（International Standards Organization）的 MPEG（Moving Picture Experts Group），这个是 ISO 旗下的 MPEG，本来是做视频存储的。例如，编码后保存在 VCD 和 DVD 中。当然后来也慢慢侧重视频传输了。名词系列三，就是这个组织制定的标准。

后来，ITU-T（国际电信联盟电信标准化部门，ITU Telecommunication Standardization Sector）与 MPEG 联合制定了 H.264/MPEG-4 AVC，这才是我们这一节要重点关注的。

---
### 直播技术的流程

![直播过程.jpg](.\pic\计算机网络\流媒体协议\直播过程.jpg)

#### 编码

- I 帧，也称关键帧。里面是完整的图片，只需要本帧数据，就可以完成解码。
- P 帧，前向预测编码帧。P 帧表示的是这一帧跟之前的一个关键帧（或 P 帧）的差别，解码时需要用之前缓存的画面，叠加上和本帧定义的差别，生成最终画面。
- B 帧，双向预测内插编码帧。B 帧记录的是本帧与前后帧的差别。要解码 B 帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的数据与本帧数据的叠加，取得最终的画面。

![IPB.jpg](.\pic\计算机网络\流媒体协议\IPB.jpg)

![网络传输视频.jpg](.\pic\计算机网络\流媒体协议\网络传输视频.jpg)

一个视频，可以拆分成一系列的帧，每一帧拆分成一系列的片，每一片都放在一个 NALU 里面，NALU 之间都是通过特殊的起始标识符分隔，在每一个 I 帧的第一片前面，要插入单独保存 SPS 和 PPS 的 NALU，最终形成一个长长的 NALU 序列。

#### 推流

RTMP协议

![RTMP.jpg](.\pic\计算机网络\流媒体协议\RTMP.jpg)

RTMP例子

![RTMP例子.jpg](.\pic\计算机网络\流媒体协议\RTMP例子.jpg)

RTMP过程

![RTMP过程.jpg](.\pic\计算机网络\流媒体协议\RTMP过程.jpg)

#### 拉流

客户端通过 RTMP 拉流的过程

RTMP拉流

![RTMP拉流.jpg](.\pic\计算机网络\流媒体协议\RTMP拉流.jpg)

先读到的是 H.264 的解码参数，例如 SPS 和 PPS，然后对收到的 NALU 组成的一个个帧，进行解码，交给播发器播放，一个绚丽多彩的视频画面就出来了。

### 小结

- 视频名词比较多，编码两大流派达成了一致，都是通过时间、空间的各种算法来压缩数据；
- 压缩好的数据，为了传输组成一系列 NALU，按照帧和片依次排列；
- 排列好的 NALU，在网络传输的时候，要按照 RTMP 包的格式进行包装，RTMP 的包会拆分成 Chunk 进行传输；
- 推送到流媒体集群的视频流经过转码和分发，可以被客户端通过 RTMP 协议拉取，然后组合为 NALU，解码成视频格式进行播放。

---
## 17.P2P

### FTP 的两种工作模式

- FTP
  - 文件传输协议
- FTP采用两个TCP连接
  - 控制连接
  - 数据连接
- FTP 的两种工作模式
  - 主动模式（PORT）
    - FTP服务器主动使用20端口连接客户端提供的端口，进行数据传输
  - 被动模式（PASV）
    - 客户端向21端口提交被动模式命令，服务器端返回一个端口（大于1024），客户端用自己的端口去连接这个端口传输数据

### P2P 是什么

- HTTP与FTP问缺点
  - 单一服务器带宽压力大
- P2P
  - peer-to-peer
  - 资源分布式储存在peer中
  - 下载文件时，会加入peer，从各个peer中获取数据，同时上传自己的资源

### 种子（.torrent）文件

- 如何获取拥有你想要文件的peer
  - 种子文件.torrent
    - announce（tracker URL）
    - 文件信息
      - info区
        - 几个文件
        - 文件长度
        - 目录结构
        - 目录和文件的名字
      - Name字段
        - 顶层目录的名字
      - 每个段的大小
      - 段的哈希值
- 下载过程
  1. BT客户端解析.torrent文件，得到tracker服务器地址
  2. tracker服务器回应，回复发布者和其他下载者的IP
  3. 客户端连接这些IP，两者分别对方告知自己已经有的块，然后交换对方没有的数据，此过程不需要服务器参与，降低服务器流量
  4. 下载到每个块后会计算hash，与.torrent中的作对比，不一致需要重新下载
- P2P的问题
  - 依赖tracker服务器的可靠性

### 去中心化网络（DHT）

- 如何彻底去中心化
  -  DHT（Distributed Hash Table）
     -  每个加入这个网络的人都负责存储资源信息和其他成员信息。做分布式储存
     -  Kademlia 协议
        - 客户端启动之后
          - TCP peer角色
          - UDP DHT node角色
        - DHT node有自己独有的ID
          - 每个节点负责保存**对应**文件所存储的位置，而不会文件本身

![DHT.jpg](.\pic\计算机网络\P2P\DHT.jpg)

### 哈希值

- 每个节点**对应**哪些文件
  - 与id一致的文件hash
  - 与文件hash临近n个节点id也会记录
    - 防止没有这个节点
    - 防止节点下线
- 新节点加入DHT网络
  - 解析种子文件
    - 种子文件中是一个node的list
  - 新节点通过一个node加入DHT网络
  - **读取**自己要下载文件的hash，从而找到对应的node节点
  - 但是无法直接连接这个node，需要通过向已连接的node查询，根据六度分隔理论，查询出对应node的联系方式。如果没有这个node，就联系临近n个节点
  - 然后找到的节点会返回它保存的tracker地址
  - 之后就可以选择其中一个开始下载了
  - 之后告知对应node和临近n个node，将自己加入这个下载文件的node list中
  - 之后一些符合新节点ID的文件索引信息也会保存在新节点的本地
- 其中存在的问题
  - ID和hash分别是什么
    - 160bit，20字节的字符串
  - ID类似如何定义
    - XOR两个ID的结果就是距离
    - 其大小与物理位置无关


### DHT 网络中的朋友圈是怎么维护

- k-bucket-n
  - 从倒数第n位开始不同
  - 每层k个

### DHT 网络是如何查找朋友

- 通过XOR结果，判断节点在k-bucket-n
  - 如果n层中有，直接找到
  - 如果没有，在n层随便找一个，进行同样的查询
  - 其时间复杂度为log（n）

示例

A 和 B 每一位都不一样，所以相差 31，A 找到的朋友 C，不巧正好在中间。和 A 的距离是 16，和 B 距离为 15，于是 C 去自己朋友圈找的时候，不巧找到 D，正好又在中间，距离 C 为 8，距离 B 为 7。于是 D 去自己朋友圈找的时候，不巧找到 E，正好又在中间，距离 D 为 4，距离 B 为 3，E 在朋友圈找到 F，距离 E 为 2，距离 B 为 1，最终在 F 的朋友圈距离 1 的地方找到 B。当然这是最最不巧的情况，每次找到的朋友都不远不近，正好在中间。如果碰巧了，在 A 的朋友圈里面有 G，距离 B 只有 3，然后在 G 的朋友圈里面一下子就找到了 B，两次就找到了。

![DHT查询.jpg](.\pic\计算机网络\P2P\DHT查询.jpg)

- 各个节点如何沟通
  - PING
  - STORE
  - FIND_NODE
  - FIND_VALUE
- 朋友圈如何更新
- 每个 bucket 里的节点，都按最后一次接触的时间倒序排列，这就相当于，朋友圈里面最近联系过的人往往是最熟的。
- 每次执行四个指令中的任意一个都会触发更新。
- 当一个节点与自己接触时，检查它是否已经在 k-bucket 中，也就是说是否已经在朋友圈。如果在，那么将它挪到 k-bucket 列表的最底，也就是最新的位置，刚联系过，就置顶一下，方便以后多联系；如果不在，新的联系人要不要加到通讯录里面呢？假设通讯录已满的情况，PING 一下列表最上面，也即最旧的一个节点。如果 PING 通了，将旧节点挪到列表最底，并丢弃新节点，老朋友还是留一下；如果 PING 不通，删除旧节点，并将新节点加入列表，这人联系不上了，删了吧。

### 小结

- 下载一个文件可以使用 HTTP 或 FTP，这两种都是集中下载的方式，而 P2P 则换了一种思路，采取非中心化下载的方式；
- P2P 也是有两种，一种是依赖于 tracker 的，也即元数据集中，文件数据分散；另一种是基于分布式的哈希算法，元数据和文件数据全部分散。





---
## 18.DNS

### DNS服务器

### DNS解析流程

### 负载均衡

### 示例：DNS 访问数据中心中对象存储上的静态资源


### 小结

- DNS 是网络世界的地址簿，可以通过域名查地址，因为域名服务器是按照树状结构组织的，因而域名查找是使用递归的方法，并通过缓存的方式增强性能；
- 在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。

---
## 19.HTTPDNS

### 传统DNS存在的问题

#### 1.域名缓存问题

#### 2.域名转发问题

#### 3.出口NAT问题

#### 4.域名更新问题

#### 5.解析延迟问题

### HTTPDNS的工作模式

### HTTPDNS 的缓存设计

### HTTPDNS 的调度设计



### 小结

- 传统的 DNS 有很多问题，例如解析慢、更新不及时。因为缓存、转发、NAT 问题导致客户端误会自己所在的位置和运营商，从而影响流量的调度。
- HTTPDNS 通过客户端 SDK 和服务端，通过 HTTP 直接调用解析 DNS 的方式，绕过了传统 DNS 的这些缺点，实现了智能的调度。

---
## 20.CDN


### 小结

- CDN 和电商系统的分布式仓储系统一样，分为中心节点、区域节点、边缘节点，而数据缓存在离用户最近的位置。
- CDN 最擅长的是缓存静态数据，除此之外还可以缓存流媒体数据，这时候要注意使用防盗链。它也支持动态数据的缓存，一种是边缘计算的生鲜超市模式，另一种是链路优化的冷链运输模式。

---
## 21.数据中心



### 小结

- 数据中心分为三层。服务器连接到接入层，然后是汇聚层，再然后是核心层，最外面是边界路由器和安全设备。
- 数据中心的所有链路都需要高可用性。服务器需要绑定网卡，交换机需要堆叠，三层设备可以通过等价路由，二层设备可以通过 TRILL 协议。
- 随着云和大数据的发展，东西流量相对于南北流量越来越重要，因而演化为叶脊网络结构。

---
## 22.VPN

### VPN 是如何工作的

### IPsec VPN 的建立过程

### 小结

- VPN 可以将一个机构的多个数据中心通过隧道的方式连接起来，让机构感觉在一个数据中心里面，就像自驾游通过琼州海峡一样；
- 完全基于软件的 IPsec VPN 可以保证私密性、完整性、真实性、简单便宜，但是性能稍微差一些；
- MPLS-VPN 综合和 IP 转发模式和 ATM 的标签转发模式的优势，性能较好，但是需要从运营商购买。

---
## 23.移动网络

### 移动网络的发展

#### 2G

#### 2.5G

#### 3G

#### 4G

### 4G 网络协议解析

#### 控制面协议

#### 数据面协议

#### 手机上网流程

#### 异地上网问题

### 小结

- 移动网络的发展历程从 2G 到 3G，再到 4G，逐渐从打电话的功能为主，向上网的功能为主转变；
- 请记住 4G 网络的结构，有 eNodeB、MME、SGW、PGW 等，分控制面协议和数据面协议，你可以对照着结构，试着说出手机上网的流程；
- 即便你在国外的运营商下上网，也是要通过国内运营商控制的，因而也上不了脸书。


---